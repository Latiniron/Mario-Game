<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mario Game</title>
  <meta name="description" content="Mario Game — ein kleines Browser-Spiel" />
  <link rel="canonical" href="https://latiniron.github.io/Mario-Game/" />
  <meta property="og:url" content="https://latiniron.github.io/Mario-Game/" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mario Game" />
  <meta property="og:description" content="Mario Game — ein kleines Browser-Spiel" />
  <meta property="og:image" content="https://latiniron.github.io/Mario-Game/MarioGame.jpg" />
  <meta name="author" content="ChatGPT - Beispielprojekt">
  <meta name="license" content="MIT">
  
  <style>
    :root{--bg:#78c0ff;--ground:#6b4f2f;--block:#c77f3a;--player:#ffdd57;--enemy:#d9534f;--coin:#ffd700}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, sans-serif;background:var(--bg);}
    #gameWrap{display:flex;flex-direction:column;align-items:center;padding:12px}
    canvas{background:linear-gradient(#78c0ff 0%, #a0e1ff 60%);border:6px solid #333;border-radius:8px;image-rendering:pixelated}
    #hud{width:800px;max-width:95%;display:flex;justify-content:space-between;margin-top:8px;color:#222}
    .btn{padding:6px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.2);cursor:pointer;background:white}
    #info{font-size:14px}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="800" height="450"></canvas>
    <div id="hud">
      <div id="info">Punkte: <span id="score">0</span> • Leben: <span id="lives">3</span></div>
      <div>
        <button id="restart" class="btn">Neu starten</button>
        <button id="fullscreen" class="btn">Vollbild</button>
      </div>
    </div>
    <div style="max-width:800px;margin-top:10px;color:#222;font-size:13px;">
      Steuerung: ← → oder A/D zum laufen, Leertaste oder W zum springen. Sammle Münzen, vermeide Gegner.
    </div>
  </div>

  <script>
  // Der vollständige Spiel-JavaScript-Code (Game-Code)
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const restartButton = document.getElementById('restart');
    const fullscreenButton = document.getElementById('fullscreen');
    
    // --- Spielkonstanten ---
    const TILE_SIZE = 30; // Größe der Kacheln (Blöcke, Gegner, Spieler)
    const GRAVITY = 0.9; // Schwerkraft
    const JUMP_VELOCITY = -15; // Sprunghöhe
    const WALK_SPEED = 5; // Laufgeschwindigkeit
    
    // --- Spielzustand ---
    let player = {
      x: TILE_SIZE * 2,
      y: canvas.height - TILE_SIZE * 2,
      width: TILE_SIZE,
      height: TILE_SIZE * 1.5,
      velX: 0,
      velY: 0,
      onGround: false,
      isJumping: false
    };
    let score = 0;
    let lives = 3;
    let gameOver = false;
    
    // --- Level-Definition (0=Luft, 1=Boden/Block, 2=Gegner, 3=Münze) ---
    const LEVEL = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];
    
    // Level-Objekte (Gegner und Münzen)
    let levelObjects = [];
    
    function initLevel() {
      levelObjects = [];
      for (let y = 0; y < LEVEL.length; y++) {
        for (let x = 0; x < LEVEL[y].length; x++) {
          const type = LEVEL[y][x];
          if (type === 2) { // Gegner
            levelObjects.push({
              x: x * TILE_SIZE,
              y: y * TILE_SIZE,
              width: TILE_SIZE,
              height: TILE_SIZE,
              type: 'enemy',
              velX: -1,
              isAlive: true
            });
          } else if (type === 3) { // Münze
            levelObjects.push({
              x: x * TILE_SIZE,
              y: y * TILE_SIZE,
              width: TILE_SIZE * 0.8,
              height: TILE_SIZE * 0.8,
              type: 'coin',
              isCollected: false
            });
          }
        }
      }
      resetPlayer();
      score = 0;
      lives = 3;
      gameOver = false;
      updateHUD();
    }
    
    function resetPlayer() {
      player.x = TILE_SIZE * 2;
      player.y = canvas.height - TILE_SIZE * 2 - player.height;
      player.velX = 0;
      player.velY = 0;
      player.onGround = false;
      player.isJumping = false;
    }
    
    // --- Zeichnen ---
    function drawRect(x, y, w, h, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);
    }
    
    function drawLevel() {
      for (let y = 0; y < LEVEL.length; y++) {
        for (let x = 0; x < LEVEL[y].length; x++) {
          const type = LEVEL[y][x];
          if (type === 1) { // Block/Boden
            drawRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE, 'var(--block)');
            // Ein dunklerer Streifen für mehr "Tiefe"
            ctx.fillStyle = 'var(--ground)';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE * 0.8, TILE_SIZE, TILE_SIZE * 0.2);
          }
        }
      }
    }
    
    function drawObjects() {
      levelObjects.forEach(obj => {
        if (obj.type === 'enemy' && obj.isAlive) {
          drawRect(obj.x, obj.y, obj.width, obj.height, 'var(--enemy)');
        } else if (obj.type === 'coin' && !obj.isCollected) {
          // Münze als gelber Kreis darstellen
          ctx.fillStyle = 'var(--coin)';
          ctx.beginPath();
          ctx.arc(obj.x + obj.width / 2, obj.y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }
    
    function drawPlayer() {
      drawRect(player.x, player.y, player.width, player.height, 'var(--player)');
    }
    
    function draw() {
      // Hintergrund wird bereits durch das Canvas-Styling festgelegt
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    
      drawLevel();
      drawObjects();
      drawPlayer();
      
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '48px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        ctx.font = '24px Inter';
        ctx.fillText('Punkte: ' + score, canvas.width / 2, canvas.height / 2 + 50);
      }
    }
    
    // --- Kollision und Logik ---
    function checkCollision(r1, r2) {
      return r1.x < r2.x + r2.width &&
             r1.x + r1.width > r2.x &&
             r1.y < r2.y + r2.height &&
             r1.y + r1.height > r2.y;
    }
    
    function updatePlayer() {
      if (gameOver) return;
    
      // Schwerkraft
      player.velY += GRAVITY;
      
      // Bewegung anwenden
      player.x += player.velX;
      player.y += player.velY;
      
      // Zurücksetzen des onGround-Status
      player.onGround = false;
    
      // Kollision mit Level-Blöcken
      const playerNext = { ...player, x: player.x, y: player.y };
      for (let y = 0; y < LEVEL.length; y++) {
        for (let x = 0; x < LEVEL[y].length; x++) {
          if (LEVEL[y][x] === 1) {
            const block = {
              x: x * TILE_SIZE,
              y: y * TILE_SIZE,
              width: TILE_SIZE,
              height: TILE_SIZE
            };
    
            if (checkCollision(playerNext, block)) {
              const dx = (playerNext.x + playerNext.width / 2) - (block.x + block.width / 2);
              const dy = (playerNext.y + playerNext.height / 2) - (block.y + block.height / 2);
              const combinedHalfWidths = playerNext.width / 2 + block.width / 2;
              const combinedHalfHeights = playerNext.height / 2 + block.height / 2;
              
              const overlapX = combinedHalfWidths - Math.abs(dx);
              const overlapY = combinedHalfHeights - Math.abs(dy);
    
              if (overlapX < overlapY) { // X-Kollision (Seite)
                if (dx > 0) {
                  player.x = block.x + block.width; // Von links kollidiert
                } else {
                  player.x = block.x - player.width; // Von rechts kollidiert
                }
                player.velX = 0;
              } else { // Y-Kollision (Oben/Unten)
                if (dy > 0) {
                  player.y = block.y + block.height; // Von unten kollidiert (Kopf anschlagen)
                  player.velY = 0;
                } else {
                  player.y = block.y - player.height; // Von oben kollidiert (Auf dem Boden landen)
                  player.velY = 0;
                  player.onGround = true;
                  player.isJumping = false;
                }
              }
            }
          }
        }
      }
      
      // Kollision mit Spielobjekten (Münzen, Gegner)
      levelObjects.forEach(obj => {
        if (checkCollision(player, obj)) {
          if (obj.type === 'coin' && !obj.isCollected) {
            obj.isCollected = true;
            score += 10;
            updateHUD();
          } else if (obj.type === 'enemy' && obj.isAlive) {
            // Überprüfen, ob der Spieler von oben auf den Gegner springt
            const playerBottom = player.y + player.height;
            const enemyTop = obj.y;
            // Wir verwenden eine kleine Toleranz und prüfen, ob der Spieler fällt
            if (player.velY > 0 && playerBottom < enemyTop + 10) {
              // Gegner besiegen
              obj.isAlive = false;
              player.velY = JUMP_VELOCITY * 0.5; // Kleiner Rücksprung
              score += 50;
              updateHUD();
            } else {
              // Spieler stirbt
              takeDamage();
            }
          }
        }
      });
      
      // Randbegrenzung (Verhindern, dass der Spieler aus dem Level fällt/läuft)
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
      
      // Fall ins "Nichts" (unterer Rand)
      if (player.y > canvas.height) {
        takeDamage(true); // Eindeutiger Tod
      }
    }
    
    function takeDamage(instantKill = false) {
      if (gameOver) return;
    
      if (instantKill || lives === 1) {
        lives = 0;
        gameOver = true;
      } else {
        lives--;
        resetPlayer(); // Spieler zurücksetzen
      }
      updateHUD();
    }
    
    function updateEnemies() {
      levelObjects.filter(obj => obj.type === 'enemy' && obj.isAlive).forEach(enemy => {
        // Einfache Bewegung: Nur horizontal
        enemy.x += enemy.velX;
    
        // Kollision mit Blöcken, um die Richtung umzukehren
        let nextX = enemy.x + enemy.velX;
        let collisionFound = false;
        
        // Block-Check für Richtungswechsel und Boden
        for (let y = 0; y < LEVEL.length; y++) {
          for (let x = 0; x < LEVEL[y].length; x++) {
            if (LEVEL[y][x] === 1) {
              const block = {
                x: x * TILE_SIZE,
                y: y * TILE_SIZE,
                width: TILE_SIZE,
                height: TILE_SIZE
              };
    
              const enemyNext = { ...enemy, x: nextX, y: enemy.y };
              
              if (checkCollision(enemyNext, block)) {
                // Kollidiert die Seite des Gegners mit einem Block?
                if (enemy.y < block.y + block.height && enemy.y + enemy.height > block.y) {
                    collisionFound = true;
                }
              }
              
              // Prüfe, ob vor dem Gegner ein Abgrund ist
              let lookAheadX = enemy.velX > 0 ? enemy.x + enemy.width + 1 : enemy.x - 1;
              let floorY = enemy.y + enemy.height + 1; // Eine Einheit unter dem Gegner
              let gridX = Math.floor(lookAheadX / TILE_SIZE);
              let gridY = Math.floor(floorY / TILE_SIZE);
              
              if (gridX >= 0 && gridX < LEVEL[0].length && gridY < LEVEL.length) {
                  if (LEVEL[gridY][gridX] !== 1) {
                      // Abgrund gefunden (kein Block unter der nächsten Position)
                      collisionFound = true;
                  }
              }
            }
          }
        }
    
        if (collisionFound) {
          enemy.velX *= -1; // Richtung umkehren
        }
      });
    }
    
    function update() {
      if (gameOver) return;
    
      updatePlayer();
      updateEnemies();
    }
    
    // --- Game Loop und Events ---
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    function updateHUD() {
      scoreElement.textContent = score;
      livesElement.textContent = lives;
    }
    
    // Tastatur-Eingaben
    const keys = {
      ArrowLeft: false,
      ArrowRight: false,
      KeyA: false,
      KeyD: false,
      Space: false,
      KeyW: false
    };
    
    function handleKeyDown(e) {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = true;
      }
    
      if (!gameOver) {
        if ((e.code === 'ArrowLeft' || e.code === 'KeyA')) {
          player.velX = -WALK_SPEED;
        } else if ((e.code === 'ArrowRight' || e.code === 'KeyD')) {
          player.velX = WALK_SPEED;
        }
    
        if ((e.code === 'Space' || e.code === 'KeyW') && player.onGround) {
          player.velY = JUMP_VELOCITY;
          player.onGround = false;
          player.isJumping = true;
        }
      }
    }
    
    function handleKeyUp(e) {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = false;
      }
      
      // Stoppen der Bewegung, wenn die Taste losgelassen wird
      if (e.code === 'ArrowLeft' || e.code === 'KeyA' || e.code === 'ArrowRight' || e.code === 'KeyD') {
        // Nur stoppen, wenn nicht die andere Richtungstaste noch gedrückt ist
        if (!keys.ArrowLeft && !keys.KeyA && !keys.ArrowRight && !keys.KeyD) {
            player.velX = 0;
        } else if (keys.ArrowLeft || keys.KeyA) {
             player.velX = -WALK_SPEED;
        } else if (keys.ArrowRight || keys.KeyD) {
            player.velX = WALK_SPEED;
        }
      }
    }
    
    function handleRestart() {
      initLevel();
    }
    
    function handleFullscreen() {
      if (canvas.requestFullscreen) {
        canvas.requestFullscreen();
      } else if (canvas.mozRequestFullScreen) { /* Firefox */
        canvas.mozRequestFullScreen();
      } else if (canvas.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
        canvas.webkitRequestFullscreen();
      } else if (canvas.msRequestFullscreen) { /* IE/Edge */
        canvas.msRequestFullscreen();
      }
    }
    
    // Event Listener hinzufügen
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    restartButton.addEventListener('click', handleRestart);
    fullscreenButton.addEventListener('click', handleFullscreen);
    
    // Spiel starten
    initLevel();
    gameLoop();
  </script>
</body>
</html>


